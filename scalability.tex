%INTRO: (section title is in main file.)
%\subsection{scalability.tex}
The scalability of a system, in general, describes how well a system can handle increasing workload, stored data and utilization.
A system is considered scalable when it can be extended to support an increasing load with a well manageable cost increase.
On the contrary, for an unscalable system supporting increased load might be technically infeasible or prohibitively expensive.~\cite{bondi2000scalability}

As one of the key advantages of multi-tenant applications is a higher utilization of resources and the associated cost reduction per tenant.~\cite{bezemer2010multi} 
It is required that a multi-tenant application is scalable to maintain this cost reduction and to accommodate for the, hopefully, ever increasing number of tenants.

In the scalability section we will focus specifically on how the infrastructure, or specific parts thereof, of a multi-tenant application can deal with an increasing number of tenants.

\subsection{Scaling multi-tenant applications}
Scalability in the application layer is about dealing with an increasing amount of tenants on the existing infrastructure.
Multi-tenant related research in this area focuses on estimating the resources required for new and existing tenants and how to use the multi-tenant characteristics of applications to improve these estimates. 

For multi-tenant applications it is very important to avoid both under and over utilization of resources.
Under utilization causes unneeded costs and over utilization leads to degraded performance.

Espadas et.al.~\cite{espadas2013tenant} propose a resource allocation model for scaling SaaS applications.
Their proposed system uses a core SaaS application that handles incoming requests.
This application maintains a tenant context that tracks the number of logged in users, services used by the tenants and the resource consumption of the tenant.
Based on the data stored in the context the system determines the amount of resources currently required by the tenants and adjusts the amount of allocated resources if needed.

Performance tests with the new model lead to a statistically significant reduction in under utilization, but no statistically significant reduction in over utilization.

%TODO: Paper thomas kwok.

\subsection{Scalability in the data layer}
The schema of the data model presented in a multi-tenant application should be extensible by tenants.
Extensibility is required because this allows tenants to modify their view of the application in such a way that a better fits their needs.

Within a \ac{MTA} the data layer will have to deal with two things when it comes to scalability.
First, as the number of tenants increases so will database load.
Second, as the number of tenants increases so will the amount of extensions on the the schema.
The database should  manage simultaniously increasing load and schena complexity in a scalable way.

Scaling a database under just increasing load is not a multi-tenant specific problem and for most \acp{RDBMS} solutions exist for this. 
For instance, PostgreSQL has several available solutions for scaling and clustering\footnote{http://wiki.postgresql.org/wiki/Replication,\_Clustering,\_and\_Connection\_Pooling (March 2014)}, and so does MySQL.\footnote{https://www.mysql.com/products/cluster/scalability.html (March 2014)}

Thus the multi-tenant specific problem in the data layer of \acp{MTA} is finding a method that remains scalable with increasing schema complexity and load.
Research on this subject focuses on two methods to achieve this.
First, how to efficiently map the extensible schema onto existing \acp{RDBMS}.~\cite{aulbach2008multi, aulbach2009comparison} 
Or, more recently, on creating multi-tenant aware \acp{RDBMS}.~\cite{schiller2011native, aulbach2011extensibility} 

\subsubsection{Schema mapping techniques}
Schema mapping techniques are techniques for mapping an extensible schema into a traditional \ac{RDBMS}.
This mapping is usually managed in an application layer that performs various operations. 
Typically this layer rewrites queries from tenants into a generic query that can be executed on a database shared among tenants.

Schema mapping techniques for multi-tenant applications can be separated into two groups. 
One group in which the database 'owns' the schema and the other group where the application 'owns' the schema and maps this into generic database structures.~\cite{aulbach2009comparison}

\begin{description}
	\item[Database owned schema: ] The most basic case for database owned schema is an unextensible schema.
		In this case the entities in the application are mapped to their own tables.
		Each table is augmented with a 'tenantId' column that binds specific rows to specific tenants.~\cite{aulbach2008multi}

		In the case of a shared database and schema extension tables can be used to allow for tenant specific extensions.
		This is a method that finds its roots in de decomposed storage model.~\cite{copeland1985decomposition}
		These are tables that contain the additional columns added by tenants. 
		Based on a stored 'tenantid' and 'rowid' the extension tables are joined with the base table when data is fetched from the database.~\cite{aulbach2008multi}

		In the case of a private schema, where each tenant has his own set of tables, or a private database per tenant the base database schema can be extended in the traditional way by adding columns.~\cite{aulbach2009comparison}
		Each tenant has his own set of tables in these cases so the extensions will always remain private. 
	
		A major scalability issue in these cases is that, assuming the schema must be extensible, the number of tables increases with the number of tenants, as every new tenant might add additional extensions.
		A very large amount of tables in a database can result in reduced performance.~\cite{aulbach2008multi}
	\item[Application owned schema: ] In the cases where the application owns the schema there generally is a clear seperation between the logical schema, the entities and their relations as seen and used in the application and the database schema.
\end{description}

%In the mappings discussed below the database does not own the schema. 
%For most layouts below this means that knowledge of column names and types are kept in the application or middleware that is using the database for storage. 
%\begin{description}
%	\item[Universal table(s)]
%		The universal table is a schema layout where there exists one generic table with a tenant column, table column and a large number of generic data columns.
%		Onto this table several logical entities can be mapped.
%		In this mapping the nth column of the logical entity will map to the nth generic field of its row in the universal table.
%		The application or middleware will have to keep track of the mappings for the entities used in the application.
%
%		The advantage to this layout is that the different tenants are able to extend the same table in different ways. 
%		Another advantage is that all columns in a row are kept together. 
%		This makes it easy to reconstruct the original entity.
%		The disadvantage are that the table will have to be very wide and it will contain a lot of NULLs. 
%		Although some \acp{DBMS} have mechanisms to handle this efficiently, such as the SQL Server Sparse Columns feature.\footnote{http://technet.microsoft.com/en-us/library/cc280604.aspx (March 2014)}.
%		Another disadvantage is that it will be difficult to support custom indices, either all tenants get an index on a column or none do.~\cite{aulbach2008multi}
%	\item[Pivot tables]
%		Pivot tables are a different implementation of the universal table.
%		In a pivot table every column entry from a logical entity gets its own row. 
%		This leads to a layout that looks like "TenantId, EntityId, RowId, ColumnId, Data".
%
%		The advantage over a Universal table is that NULLS are not stored.
%		The disadvantage is the overhead in the database. 
%		This schema contains more metadata columns than data columns, and for a logical entity with $n$ columns $(n-1)$ joins on the pivot table are needed to reconstruct it.~\cite{aulbach2008multi}
%	\item[Extension fields]
%		In the extension field layout for every entity a table.
%		All tables of extensible entities contain an extra field that stores extensions in a structured format like XML or JSON.
%		Certain \acp{RDBMS} support accessing data within such a field. 
%		DB2 does this for XML trough PureXML\footnote{http://www-01.ibm.com/software/data/db2/linux-unix-windows/xml/index.html (march 2014)} and Postgres allows for reading values from JSON fields\footnote{http://www.postgresql.org/docs/9.3/static/functions-json.html (March 2014)}

%		The advantage of this schema is that extensions are kept in a single field and that its a very basic extension of the basic layout.
%		However reading from the extension field will introduce additional overhead.~\cite{aulbach2009comparison}
%\end{description}

\subsubsection{Tenant aware \acp{DBMS}}
Schiller et.al.~\cite{schiller2011native} propose a database with native multi-tenancy support and support for schema extensibility.
Using their approach a tenant object would exist within the database as a first-class object. 
Based on these objects for each tenant a context can be maintained that allows the database to determine what data belongs to a specific tenant. 
These contexts also facilitate direct access to the database for applications without needing a query rewriter.

Both Schiller~\cite{schiller2011native} and Aulbach~\cite{aulbach2011extensibility} propose a model where tenants can extend the schema in an object-oriented way.
Allowing tenants to share the base table and transparently applying the extensions depending on the tenant executing a query.

Schiller also implemented a prototype tenant-aware \ac{RDBMS}.
This prototype specifically implemented support for the tenant context and extensibility.
However it is unclear whether their approach really meets the requirements of a multi-tenant application.


%Allocation of resources for new tenants, predicting & preventing conflicts / bottlenecks.
% Espadas et.al en Thomas Kwok et.al.

\subsection{Research Agenda for Scalability}
Both Kwok et.al.~\cite{kwok2008resource} and Espadas et.al.~\cite{espadas2013tenant} name identifying bottlenecks and validating existing and proposed methods as the primary challenge.
In addition Espadas recommended finding new models and mechanisms for measuring machine statuses and metrics.

For the storage layer Aulbach et.al.~\cite{aulbach2009comparison, aulbach2008multi} and Schiller et.al.~\cite{schiller2011native} want further research into tenant-databases. The current prototypes are still incomplete and are seen as a basis for further research and development.

