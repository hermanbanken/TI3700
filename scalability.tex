%INTRO: (section title is in main file.)
%\subsection{scalability.tex}
The scalability of a system, in general, describes how well a system can handle increasing workload, stored data and utilization.
A system is considered scalable when it can be extended to support an increasing load with a well manageable cost increase.
On the contrary, for an unscalable system supporting increased load might be technically infeasible or prohibitively expensive.~\cite{bondi2000scalability}

As one of the key advantages of multi-tenant applications is a higher utilization of resources and the associated cost reduction per tenant.~\cite{bezemer2010multi} 
It is required that a multi-tenant application is scalable to maintain this cost reduction and to accommodate for the, hopefully, ever increasing number of tenants.

In the scalability section we will focus specifically on how the infrastructure, or specific parts thereof, of a multi-tenant application can deal with an increasing number of tenants.

\subsection{Scaling multi-tenant applications}
Scalability in the application layer is about dealing with an increasing amount of tenants on the existing infrastructure.
Multi-tenant related research in this area focuses on estimating the resources required for new and existing tenants and how to use the multi-tenant characteristics of applications to improve these estimates. 

For multi-tenant applications it is very important to avoid both under and over utilization of resources.
Under utilization causes unneeded costs and over utilization leads to degraded performance.

Espadas et.al.~\cite{espadas2013tenant} propose a resource allocation model for scaling SaaS applications.
Their proposed system uses a core SaaS application that handles incoming requests.
This application maintains a tenant context that tracks the number of logged in users, services used by the tenants and the resource consumption of the tenant.
Based on the data stored in the context the system determines the amount of resources currently required by the tenants and adjusts the amount of allocated resources if needed.

Performance tests with the new model lead to a statistically significant reduction in under utilization, but no statistically significant reduction in over utilization.

%TODO: Paper thomas kwok.

\subsection{Scalability in the data layer}
The schema of the data model presented in a multi-tenant application should be extensible by tenants.
Extensibility is required because this allows tenants to modify their view of the application in such a way that a better fits their needs.

Within a \ac{MTA} the data layer will have to deal with two things when it comes to scalability.
First, as the number of tenants increases so will database load.
Second, as the number of tenants increases so will the amount of extensions on the the schema.
The database should  manage simultaniously increasing load and schena complexity in a scalable way.

Scaling a database under just increasing load is not a multi-tenant specific problem and for most \acp{RDBMS} solutions exist for this. 
For instance, PostgreSQL has several available solutions for scaling and clustering\footnote{http://wiki.postgresql.org/wiki/Replication,\_Clustering,\_and\_Connection\_Pooling (March 2014)}, and so does MySQL.\footnote{https://www.mysql.com/products/cluster/scalability.html (March 2014)}

Thus the multi-tenant specific problem in the data layer of \acp{MTA} is finding a method that remains scalable with increasing schema complexity and load.
Research on this subject focuses on two methods to achieve this.
First, how to efficiently map the extensible schema onto existing \acp{RDBMS}.~\cite{aulbach2008multi, aulbach2009comparison} 
Or, more recently, on creating multi-tenant aware \acp{RDBMS}.~\cite{schiller2011native, aulbach2011extensibility} 

\subsubsection{Schema mapping techniques}
Schema mapping techniques are techniques for mapping an extensible schema into a traditional \ac{RDBMS}.
This mapping is usually managed in an application layer that performs various operations. 
Typically this layer rewrites queries from tenants into a generic query that can be executed on a database shared among tenants.

Schema mapping techniques for multi-tenant applications can be separated into three groups. 
One group in which the database 'owns' the schema, group where the application 'owns' the schema and maps this into generic database structures, and a group that uses a hybrid model where the database partially owns the schema.~\cite{aulbach2009comparison}

\begin{description}
	\item[Database owned schema: ] The most basic case for database owned schema is an unextensible schema.
		In this case the entities in the application are mapped to their own tables.
		Each table is augmented with a 'tenantId' column that binds specific rows to specific tenants.~\cite{aulbach2008multi}

		In the case of a shared database and schema extension tables can be used to allow for tenant specific extensions.
		This is a method that finds its roots in de decomposed storage model.~\cite{copeland1985decomposition}
		These are tables that contain the additional columns added by tenants. 
		Based on a stored 'tenantid' and 'rowid' the extension tables are joined with the base table when data is fetched from the database.~\cite{aulbach2008multi}

		In the case of a private schema, where each tenant has his own set of tables, or a private database per tenant the base database schema can be extended in the traditional way by adding columns.~\cite{aulbach2009comparison}
		Each tenant has his own set of tables in these cases so the extensions will always remain private. 
	
		A major scalability issue in these cases is that, assuming the schema must be extensible, the number of tables increases with the number of tenants, as every new tenant might add additional extensions.
		A very large amount of tables in a database can result in reduced performance.~\cite{aulbach2008multi}
	\item[Application owned schema: ] When the schema is owned by the application the logical tables used in the application are mapped to one ore more generic tables in the database.
		
		An example of such a generic structure is the universal table. 
		In a universal table layout data is stored in one very wide table containing columns for a tenant id, record id, and record type followed by $n$ generic columns with a flexible type such as VARCHAR.
		The $n$-th column of a logical entity maps to the $n$-th column in the universal table.~\cite{aulbach2008multi}. The record type and tenant id are used to match the data in the universal table to right logical tables.

		Another approach, related to the universal table, is to the pivot table. 
		In a pivot table each column from a logical table is mapped to a row in the pivot table.
		To reconstruct the data from a pivot table into the logical table seen by a tenant a tenant id, record type, record id and row id are needed in addition to the data field.~\cite{aulbach2008multi}

		These approaches eliminate the performance issue of a very large number of tables.
		However both the universal table and pivot table have their own disadvantages. 
		For the universal table this is the potential introduction of a large amount of NULLs in the database, not all storage engines are equipped to handle this in an efficient manner. 
		Additionally it is difficult to add tenant specific indexes on these tables, once a column is indexed it will be indexed for all tenants.

		The main disadvantages for the pivot table are that for a logical table with $n$ columns $(n-1)$ joins are needed to query all fields. 
		An advantage of pivot tables is that NULLs are not stored.
	\item[Hybrid schemas: ] 
\end{description}

%		However reading from the extension field will introduce additional overhead.~\cite{aulbach2009comparison}
%\end{description}

\subsubsection{Tenant aware \acp{DBMS}}
Schiller et.al.~\cite{schiller2011native} propose a database with native multi-tenancy support and support for schema extensibility.
Using their approach a tenant object would exist within the database as a first-class object. 
Based on these objects for each tenant a context can be maintained that allows the database to determine what data belongs to a specific tenant. 
These contexts also facilitate direct access to the database for applications without needing a query rewriter.

Both Schiller~\cite{schiller2011native} and Aulbach~\cite{aulbach2011extensibility} propose a model where tenants can extend the schema in an object-oriented way.
Allowing tenants to share the base table and transparently applying the extensions depending on the tenant executing a query.

Schiller also implemented a prototype tenant-aware \ac{RDBMS}.
This prototype specifically implemented support for the tenant context and extensibility.
However it is unclear whether their approach really meets the requirements of a multi-tenant application.


%Allocation of resources for new tenants, predicting & preventing conflicts / bottlenecks.
% Espadas et.al en Thomas Kwok et.al.

\subsection{Research Agenda for Scalability}
Both Kwok et.al.~\cite{kwok2008resource} and Espadas et.al.~\cite{espadas2013tenant} name identifying bottlenecks and validating existing and proposed methods as the primary challenge.
In addition Espadas recommended finding new models and mechanisms for measuring machine statuses and metrics.

For the storage layer Aulbach et.al.~\cite{aulbach2009comparison, aulbach2008multi} and Schiller et.al.~\cite{schiller2011native} want further research into tenant-databases. The current prototypes are still incomplete and are seen as a basis for further research and development.

